package k8s

import (
	"context"
	"errors"
	"fmt"
	"os"

	"github.com/Shopify/kubeaudit/k8stypes"
	log "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/version"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

// ErrNoReadableKubeConfig represents any error that prevents the client from opening a kubeconfig file.
var ErrNoReadableKubeConfig = errors.New("unable to open kubeconfig file")

var DefaultClient = k8sClient{}

// Client abstracts the API to allow testing.
type Client interface {
	InClusterConfig() (*rest.Config, error)
}

// k8sClient wraps kubernetes client-go so it can be mocked.
type k8sClient struct{}

// InClusterConfig wraps the client-go method with the same name.
func (kc k8sClient) InClusterConfig() (*rest.Config, error) {
	return rest.InClusterConfig()
}

// NewKubeClientLocal creates a new kube client for local mode
func NewKubeClientLocal(configPath string) (*kubernetes.Clientset, error) {
	if _, err := os.Stat(configPath); err != nil {
		return nil, ErrNoReadableKubeConfig
	}
	config, err := clientcmd.BuildConfigFromFlags("", configPath)
	if err != nil {
		return nil, err
	}
	kube, err := kubernetes.NewForConfig(config)
	return kube, err
}

// NewKubeClientCluster creates a new kube client for cluster mode
func NewKubeClientCluster(client Client) (*kubernetes.Clientset, error) {
	config, err := client.InClusterConfig()
	if err != nil {
		return nil, err
	}
	log.Info("Running inside cluster, using the cluster config")
	kube, err := kubernetes.NewForConfig(config)
	return kube, err
}

// IsRunningInCluster returns true if kubeaudit is running inside a cluster
func IsRunningInCluster(client Client) bool {
	_, err := client.InClusterConfig()
	return err == nil
}

type ClientOptions struct {
	// Namespace filters resources by namespace. Defaults to all namespaces.
	Namespace string
	// ExcludeGenerated filters out generated resources (eg. pods generated by deployments). Defaults to including generated resources.
	ExcludeGenerated bool
}

// GetAllResources gets all supported resources from the cluster
func GetAllResources(clientset kubernetes.Interface, options ClientOptions) []k8stypes.Resource {
	var resources []k8stypes.Resource

	for _, resource := range GetDaemonSets(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetDeployments(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetPods(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetPodTemplates(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetReplicationControllers(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetStatefulSets(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetNetworkPolicies(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetCronJobs(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}
	for _, resource := range GetNamespaces(clientset, options).Items {
		resources = append(resources, resource.DeepCopyObject())
	}

	if options.ExcludeGenerated {
		resources = excludeGenerated(resources)
	}

	return resources
}

func excludeGenerated(resources []k8stypes.Resource) []k8stypes.Resource {
	var filteredResources []k8stypes.Resource
	for _, resource := range resources {
		if len(GetObjectMeta(resource).OwnerReferences) == 0 {
			filteredResources = append(filteredResources, resource)
		}
	}
	return filteredResources
}

// GetDaemonSets gets all DaemonSet resources from the cluster
func GetDaemonSets(clientset kubernetes.Interface, options ClientOptions) *k8stypes.DaemonSetListV1 {
	daemonSetClient := clientset.AppsV1().DaemonSets(options.Namespace)
	daemonSets, err := daemonSetClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return daemonSets
}

// GetDeployments gets all Deployment resources from the cluster
func GetDeployments(clientset kubernetes.Interface, options ClientOptions) *k8stypes.DeploymentListV1 {
	deploymentClient := clientset.AppsV1().Deployments(options.Namespace)
	deployments, err := deploymentClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return deployments
}

// GetPods gets all Pod resources from the cluster
func GetPods(clientset kubernetes.Interface, options ClientOptions) *k8stypes.PodListV1 {
	podClient := clientset.CoreV1().Pods(options.Namespace)
	pods, err := podClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return pods
}

// GetPodTemplates gets all PodTemplate resources from the cluster
func GetPodTemplates(clientset kubernetes.Interface, options ClientOptions) *k8stypes.PodTemplateListV1 {
	podTemplateClient := clientset.CoreV1().PodTemplates(options.Namespace)
	podTemplates, err := podTemplateClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return podTemplates
}

// GetReplicationControllers gets all ReplicationController resources from the cluster
func GetReplicationControllers(clientset kubernetes.Interface, options ClientOptions) *k8stypes.ReplicationControllerListV1 {
	replicationControllerClient := clientset.CoreV1().ReplicationControllers(options.Namespace)
	replicationControllers, err := replicationControllerClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return replicationControllers
}

// GetStatefulSets gets all StatefulSet resources from the cluster
func GetStatefulSets(clientset kubernetes.Interface, options ClientOptions) *k8stypes.StatefulSetListV1 {
	statefulSetClient := clientset.AppsV1().StatefulSets(options.Namespace)
	statefulSets, err := statefulSetClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return statefulSets
}

// GetNetworkPolicies gets all NetworkPolicy resources from the cluster
func GetNetworkPolicies(clientset kubernetes.Interface, options ClientOptions) *k8stypes.CronJobListV1Beta1 {
	cronJobClient := clientset.BatchV1beta1().CronJobs(options.Namespace)
	cronJobs, err := cronJobClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return cronJobs
}

// GetCronJobs gets all CronJob resources from the cluster
func GetCronJobs(clientset kubernetes.Interface, options ClientOptions) *k8stypes.NetworkPolicyListV1 {
	netPolClient := clientset.NetworkingV1().NetworkPolicies(options.Namespace)
	netPols, err := netPolClient.List(context.Background(), k8stypes.ListOptionsV1{})
	if err != nil {
		log.Error(err)
	}
	return netPols
}

// GetNamespaces gets all Namespace resources from the cluster
func GetNamespaces(clientset kubernetes.Interface, options ClientOptions) *k8stypes.NamespaceListV1 {
	namespaceClient := clientset.CoreV1().Namespaces()
	listOptions := k8stypes.ListOptionsV1{}

	if options.Namespace != "" {
		// Select only the specified namespace
		listOptions.FieldSelector = fmt.Sprintf("metadata.name=%s", options.Namespace)
	}

	namespaces, err := namespaceClient.List(context.Background(), listOptions)

	if err != nil {
		log.Error(err)
	}

	return namespaces
}

// GetKubernetesVersion returns the kubernetes client version
func GetKubernetesVersion(clientset kubernetes.Interface) (*version.Info, error) {
	discoveryClient := clientset.Discovery()
	return discoveryClient.ServerVersion()
}
