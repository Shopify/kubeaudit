package k8sinternal

import (
	"context"
	"errors"
	"fmt"
	"os"

	"github.com/Shopify/kubeaudit/pkg/k8s"
	log "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/version"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	clientcmdapi "k8s.io/client-go/tools/clientcmd/api"

	// add authentication support to the kubernetes code
	_ "k8s.io/client-go/plugin/pkg/client/auth/azure"
	_ "k8s.io/client-go/plugin/pkg/client/auth/exec"
	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
	_ "k8s.io/client-go/plugin/pkg/client/auth/oidc"
	_ "k8s.io/client-go/plugin/pkg/client/auth/openstack"
)

// ErrNoReadableKubeConfig represents any error that prevents the client from opening a kubeconfig file.
var ErrNoReadableKubeConfig = errors.New("unable to open kubeconfig file")

var DefaultClient = k8sClient{}

// Client abstracts the API to allow testing.
type Client interface {
	InClusterConfig() (*rest.Config, error)
}

// k8sClient wraps kubernetes client-go so it can be mocked.
type k8sClient struct{}

// InClusterConfig wraps the client-go method with the same name.
func (kc k8sClient) InClusterConfig() (*rest.Config, error) {
	return rest.InClusterConfig()
}

// NewKubeClientLocal creates a new kube client for local mode
func NewKubeClientLocal(configPath string) (*kubernetes.Clientset, error) {
	var kubeconfig *rest.Config
	var err error

	if configPath == "" {
		kubeconfig, err = clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
			clientcmd.NewDefaultClientConfigLoadingRules(),
			&clientcmd.ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: ""}},
		).ClientConfig()
	} else {
		if _, err = os.Stat(configPath); err != nil {
			return nil, ErrNoReadableKubeConfig
		}
		kubeconfig, err = clientcmd.BuildConfigFromFlags("", configPath)
	}

	if err != nil {
		return nil, err
	}

	kube, err := kubernetes.NewForConfig(kubeconfig)
	return kube, err
}

// NewKubeClientCluster creates a new kube client for cluster mode
func NewKubeClientCluster(client Client) (*kubernetes.Clientset, error) {
	config, err := client.InClusterConfig()
	if err != nil {
		return nil, err
	}
	log.Info("Running inside cluster, using the cluster config")
	kube, err := kubernetes.NewForConfig(config)
	return kube, err
}

// IsRunningInCluster returns true if kubeaudit is running inside a cluster
func IsRunningInCluster(client Client) bool {
	_, err := client.InClusterConfig()
	return err == nil
}

type ClientOptions struct {
	// Namespace filters resources by namespace. Defaults to all namespaces.
	Namespace string
}

// GetAllResources gets all supported resources from the cluster
func GetAllResources(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	var resources []k8s.Resource

	resources = append(resources, GetDaemonSets(clientset, options)...)
	resources = append(resources, GetDeployments(clientset, options)...)
	resources = append(resources, GetPods(clientset, options)...)
	resources = append(resources, GetPodTemplates(clientset, options)...)
	resources = append(resources, GetReplicationControllers(clientset, options)...)
	resources = append(resources, GetStatefulSets(clientset, options)...)
	resources = append(resources, GetNetworkPolicies(clientset, options)...)
	resources = append(resources, GetCronJobs(clientset, options)...)
	resources = append(resources, GetServiceAccounts(clientset, options)...)
	resources = append(resources, GetNamespaces(clientset, options)...)

	resources = excludeGenerated(resources)

	return resources
}

// excludeGenerated filters out generated resources (eg. pods generated by deployments)
func excludeGenerated(resources []k8s.Resource) []k8s.Resource {
	var filteredResources []k8s.Resource
	for _, resource := range resources {
		if len(k8s.GetObjectMeta(resource).OwnerReferences) == 0 {
			filteredResources = append(filteredResources, resource)
		}
	}
	return filteredResources
}

// GetDaemonSets gets all DaemonSet resources from the cluster
func GetDaemonSets(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	daemonSetClient := clientset.AppsV1().DaemonSets(options.Namespace)
	daemonSetList, err := daemonSetClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	daemonSets := make([]k8s.Resource, 0, len(daemonSetList.Items))
	for _, daemonSet := range daemonSetList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		daemonSet.TypeMeta = k8s.NewDaemonSet().TypeMeta
		daemonSets = append(daemonSets, daemonSet.DeepCopyObject())
	}

	return daemonSets
}

// GetDeployments gets all Deployment resources from the cluster
func GetDeployments(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	deploymentClient := clientset.AppsV1().Deployments(options.Namespace)
	deploymentList, err := deploymentClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	deployments := make([]k8s.Resource, 0, len(deploymentList.Items))
	for _, deployment := range deploymentList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		deployment.TypeMeta = k8s.NewDeployment().TypeMeta
		deployments = append(deployments, (&deployment).DeepCopyObject())
	}

	return deployments
}

// GetPods gets all Pod resources from the cluster
func GetPods(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	podClient := clientset.CoreV1().Pods(options.Namespace)
	podList, err := podClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	pods := make([]k8s.Resource, 0, len(podList.Items))
	for _, pod := range podList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		pod.TypeMeta = k8s.NewPod().TypeMeta
		pods = append(pods, pod.DeepCopyObject())
	}

	return pods
}

// GetPodTemplates gets all PodTemplate resources from the cluster
func GetPodTemplates(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	podTemplateClient := clientset.CoreV1().PodTemplates(options.Namespace)
	podTemplateList, err := podTemplateClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	podTemplates := make([]k8s.Resource, 0, len(podTemplateList.Items))
	for _, podTemplate := range podTemplateList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		podTemplate.TypeMeta = k8s.NewPodTemplate().TypeMeta
		podTemplates = append(podTemplates, podTemplate.DeepCopyObject())
	}

	return podTemplates
}

// GetReplicationControllers gets all ReplicationController resources from the cluster
func GetReplicationControllers(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	replicationControllerClient := clientset.CoreV1().ReplicationControllers(options.Namespace)
	replicationControllerList, err := replicationControllerClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	replicationControllers := make([]k8s.Resource, 0, len(replicationControllerList.Items))
	for _, replicationController := range replicationControllerList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		replicationController.TypeMeta = k8s.NewReplicationController().TypeMeta
		replicationControllers = append(replicationControllers, replicationController.DeepCopyObject())
	}

	return replicationControllers
}

// GetStatefulSets gets all StatefulSet resources from the cluster
func GetStatefulSets(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	statefulSetClient := clientset.AppsV1().StatefulSets(options.Namespace)
	statefulSetList, err := statefulSetClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	statefulSets := make([]k8s.Resource, 0, len(statefulSetList.Items))
	for _, statefulSet := range statefulSetList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		statefulSet.TypeMeta = k8s.NewStatefulSet().TypeMeta
		statefulSets = append(statefulSets, statefulSet.DeepCopyObject())
	}

	return statefulSets
}

// GetCronJobs gets all CronJob resources from the cluster
func GetCronJobs(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	cronJobClient := clientset.BatchV1beta1().CronJobs(options.Namespace)
	cronJobList, err := cronJobClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	cronJobs := make([]k8s.Resource, 0, len(cronJobList.Items))
	for _, cronJob := range cronJobList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		cronJob.TypeMeta = k8s.NewCronJob().TypeMeta
		cronJobs = append(cronJobs, cronJob.DeepCopyObject())
	}

	return cronJobs
}

// GetNetworkPolicies gets all NetworkPolicy resources from the cluster
func GetNetworkPolicies(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	netPolClient := clientset.NetworkingV1().NetworkPolicies(options.Namespace)
	netPolList, err := netPolClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	netPols := make([]k8s.Resource, 0, len(netPolList.Items))
	for _, netPol := range netPolList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		netPol.TypeMeta = k8s.NewNetworkPolicy().TypeMeta
		netPols = append(netPols, netPol.DeepCopyObject())
	}

	return netPols
}

// GetServiceAccounts gets all ServiceAccount resources from the cluster
func GetServiceAccounts(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	serviceAccountClient := clientset.CoreV1().ServiceAccounts(options.Namespace)
	serviceAccountList, err := serviceAccountClient.List(context.Background(), k8s.ListOptionsV1{})

	if err != nil {
		log.Error(err)
		return nil
	}

	serviceAccounts := make([]k8s.Resource, 0, len(serviceAccountList.Items))
	for _, serviceAccount := range serviceAccountList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		serviceAccount.TypeMeta = k8s.NewServiceAccount().TypeMeta
		serviceAccounts = append(serviceAccounts, serviceAccount.DeepCopyObject())
	}

	return serviceAccounts
}

// GetNamespaces gets all Namespace resources from the cluster
func GetNamespaces(clientset kubernetes.Interface, options ClientOptions) []k8s.Resource {
	namespaceClient := clientset.CoreV1().Namespaces()
	listOptions := k8s.ListOptionsV1{}

	if options.Namespace != "" {
		// Select only the specified namespace
		listOptions.FieldSelector = fmt.Sprintf("metadata.name=%s", options.Namespace)
	}

	namespaceList, err := namespaceClient.List(context.Background(), listOptions)

	if err != nil {
		log.Error(err)
		return nil
	}

	namespaces := make([]k8s.Resource, 0, len(namespaceList.Items))
	for _, namespace := range namespaceList.Items {
		// For some reason the kubernetes SDK doesn't populate the type meta so we populate it manually
		namespace.TypeMeta = k8s.NewNamespace().TypeMeta
		namespaces = append(namespaces, (&namespace).DeepCopyObject())
	}

	return namespaces
}

// GetKubernetesVersion returns the kubernetes client version
func GetKubernetesVersion(clientset kubernetes.Interface) (*version.Info, error) {
	discoveryClient := clientset.Discovery()
	return discoveryClient.ServerVersion()
}
